// ------------------------------------------------------------------
// A D A P T I V E   Q U A D R A T U R E   I N T E G R A T I O N
//
// O P E N M P
// ------------------------------------------------------------------
// Version: 1.2
// Developed by: Alex Verkest, Tammy Hunsetdinova
//  Description: Parallel, shared memory, SIMD implementation of AQI
//               that takes boundsand error threshold as command line
//               arguments andproduces an integration of an equation
//               hardcoded within the function() function.
//         Run:  $ make
//                  or
//               $ g++ -O -fopenmp AQI-omp.cpp -o AQI-omp -std=c++11
//               $ sbatch AQI-omp_slurm.sh <lower_bound> <upper_bound> <error>
// ------------------------------------------------------------------

#include <iostream>
#include <iomanip>
#include <cmath>
#include <omp.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

using namespace std;

// F U N C T I O N :
// ------------------------------------------------------------------
// Description: Contains hardcoded f(x); the desired equation to
//              be integrated. To change f(x): edit the return
//              statement (uses c++ syntax).
//       Input: x: Float value of x to be computed by equation f(x)
//      Output: The calculated value of f(x).
// ------------------------------------------------------------------
float function(float x) {
  // return 0.005 * pow(x, 2);                         // f(x) = 1/200x^2
  // return (0.25 * x) + 4;                            // f(x) = 1/4x + 4
  // return fabs(20 * cos(x)) / 4;                     // f(x) = | 20cos(x) |/4
  return fabs( (5 * x) * ( cos(6*x) * sin(x) ) ) / 20;  // f(x) = | 5x( (cos(6x) + sin(x) ) | / 20

  // f(x) = |10 * ( cos(x^x) / (2 ^ ((x^x - pi/2) / 5))) + 4 |
}

// T R A P E Z O I D A L   A C T U A L :
// ------------------------------------------------------------------
// Description: Produces the definite integral of above function
//              using the bounds passed as parameters.
//       Input: lower_bound: Lower bound of definite integral
//              upper_bound: Upper bound of definite integral
//      Output: The calculated definite integral of function().
//      Source: https://www.geeksforgeeks.org/trapezoidal-rule-for-approximate-value-of-definite-integral/
// ------------------------------------------------------------------
float trapezoidal_actual(float lower_bound, float upper_bound) {
  int interval = 1000; // higher interval = more accurate
  float grid = (upper_bound - lower_bound) / interval;
  // Computing sum of first and last terms in function()
  float s = function(lower_bound) + function(upper_bound);
  // Adding middle terms in above formula
  for (int i = 1; i < interval; i++)
      s += 2 * function(lower_bound + i * grid);

  return (grid / 2) * s;
}

// T R A P E Z O I D A L   R U L E :
// ------------------------------------------------------------------
// Description: Produces area under f(x) using the trapezoidal rule
//              and bounds passed as parameters.
//       Input: a: Lower bound of trapezoid
//              b: Upper bound of trapezoid
//      Output: Area of trapezoid under the graphed function f(x).
// ------------------------------------------------------------------
float trapezoidal_rule(float a, float b) {
  return 0.5 * (b - a) * (function(a) + function(b));
}

// C H E C K   E R R O R :
// ------------------------------------------------------------------
// Description: Determines if delta of actual and calcuted integral
//              exceeds user error threshold.
//       Input: calculated: calculated integral of f(x) using AQI
//              actual: actual integral of f(x) generated by
//                      trapezoidal_actual()
//              error: user decided error threshold
//      Output: True: if the difference between actual and calculated
//              is less than error.
//              False: if the difference is more than the error.
// ------------------------------------------------------------------
bool check_error(float calculated, float actual, float error) {
  if (fabs(actual - calculated) > error)
    return false;
  else
    return true;
}

// A D A P T I V E   Q U A D R A T U R E :
// ------------------------------------------------------------------
// Description: Recursive function to calculate integral
//              using AQI. Newly added parallel functionality acts
//              similarly as the sequential implementation but offloads
//              new function calls to new processes.
//       Input: lower: Lower bound of definite integral
//              upper: Upper bound of definite integral
//              error: User generated error threshold
//      Output: Integration generated AQI that passed check_error().
// ------------------------------------------------------------------
float adaptive_quadrature(float lower, float upper, float error) {
  float trapezoidal_area = trapezoidal_rule(lower, upper);
  float actual_integration = trapezoidal_actual(lower, upper);
  float aqi_integration = 0.0;

  // Condition: if trapezoidal_area doesn't pass check_error() split
  //            bounds in half and use recursion to find integral
  //            that passes check_error().
  if (!check_error(trapezoidal_area, actual_integration, error)) {
    float midpoint = (upper + lower) / 2;
    #pragma omp taskq
      #pragma omp task shared(aqi_integration) firstprivate(lower, midpoint, error)
      {
        aqi_integration += adaptive_quadrature(lower, midpoint, error);
        aqi_integration += adaptive_quadrature(midpoint, upper, error);
      }
      #pragma omp taskwait
  }
  else // if trapezoidal_area passes check_error(), add it AQI
    #pragma omp critical
      aqi_integration += trapezoidal_area;

  return aqi_integration;
}

// M A I N :
// ------------------------------------------------------------------
// Description: Main driver of program. Takes command line arguments
//       Input: argv[1]: lower limit of integral
//              argv[2]: upper limit of integral
//              argv[3]: error threshold
//      Output: Printed and formatted AQI definite integration of
//              function()
// ------------------------------------------------------------------
int main(int argc, char *argv[]) {
  // Command line error message
  if (argc < 4) {
    cout << "You may be missing some arguments.\n";
    cout << "Try: <AQI> <lower limit> <upper limit> <error>\n";
    cout << ":)\n";
    exit(1);
  }

  // Store command line arguments as lower, upper, and error respectively
  float lower = stof(argv[1]);
  float upper = stof(argv[2]);
  float error = stof(argv[3]);
  float aqi = 0;

  // Runtime clock start
  double runtime = omp_get_wtime();

  // Begin parallel section
  #pragma omp parallel
    #pragma omp taskq lastprivate(aqi)
      #pragma omp task
        aqi = adaptive_quadrature(lower, upper, error);

  // Formatted Ouput
  printf("##################################\n");
  printf(" Adaptive Quadrature Integration: \n");
  printf("##################################\n");
  printf(" • Integral: ∫ %s dx \n", "<copy function here>");
  printf(" •   Bounds: %4.2f, %4.2f \n", lower, upper);
  printf(" •    Error: %4.2f \n", error);
  printf(" •      AQI: %4.2f \n", aqi);
  runtime = omp_get_wtime() - runtime;
  cout << " •  Runtime: "	<< setiosflags(ios::fixed)
                      << setprecision(4) << runtime << " seconds\n";
  //printf(" •  Runtime: %ld microseconds \n", runtime);

  return(0);
}
